// --- BEGIN fetchTomTomTrafficWithStreetNames ---
// Enhanced TomTom traffic fetcher with improved location handling and timing
async function fetchTomTomTrafficWithStreetNames() {
  if (!process.env.TOMTOM_API_KEY) {
    return { success: false, data: [], error: 'API key missing' };
  }
  
  try {
    console.log('üöó Fetching TomTom traffic with enhanced location processing...');
    
    const response = await axios.get('https://api.tomtom.com/traffic/services/5/incidentDetails', {
      params: {
        key: process.env.TOMTOM_API_KEY,
        bbox: '-1.8,54.8,-1.4,55.1', // Newcastle area
        zoom: 10
      },
      timeout: 15000,
      headers: {
        'User-Agent': 'BARRY-TrafficWatch/3.0-Enhanced',
        'Accept': 'application/json'
      }
    });
    
    console.log(`üì° TomTom: ${response.status}, incidents: ${response.data?.incidents?.length || 0}`);
    
    const alerts = [];
    
    if (response.data?.incidents) {
      // Process incidents with enhanced locations
      const realTrafficIncidents = response.data.incidents.filter(feature => {
        const props = feature.properties || {};
        // Include more incident types for better coverage
        return props.iconCategory >= 1 && props.iconCategory <= 14;
      });
      
      console.log(`üîç Processing ${realTrafficIncidents.length} traffic incidents (filtered from ${response.data.incidents.length})`);
      
      for (const [index, feature] of realTrafficIncidents.entries()) {
        if (index >= 12) break; // Increased limit to 12 for better coverage
        
        const props = feature.properties || {};
        
        // Extract coordinates with better error handling
        let lat = null, lng = null;
        try {
          if (feature.geometry?.coordinates) {
            if (feature.geometry.type === 'Point') {
              [lng, lat] = feature.geometry.coordinates;
            } else if (feature.geometry.type === 'LineString' && feature.geometry.coordinates.length > 0) {
              [lng, lat] = feature.geometry.coordinates[0];
            }
          }
        } catch (coordError) {
          console.warn(`‚ö†Ô∏è Error extracting coordinates for incident ${index}:`, coordError.message);
        }

        // ENHANCED: Get location with multiple fallback strategies
        console.log(`üó∫Ô∏è Processing location for incident ${index + 1}/${realTrafficIncidents.length}...`);
        
        let enhancedLocation;
        try {
          enhancedLocation = await getEnhancedLocationWithFallbacks(
            lat, 
            lng, 
            props.roadName || props.description || '',
            `TomTom incident ${props.iconCategory}`
          );
        } catch (locationError) {
          console.warn(`‚ö†Ô∏è Location enhancement failed for incident ${index}:`, locationError.message);
          enhancedLocation = getCoordinateDescription(lat, lng);
        }
        
        // Enhanced GTFS route matching with error handling
        let affectedRoutes = [];
        try {
          if (lat && lng) {
            console.log(`üó∫Ô∏è Finding GTFS routes for incident at ${lat}, ${lng}...`);
            affectedRoutes = await findRoutesNearCoordinate(lat, lng, 150);
          }
        } catch (routeError) {
          console.warn(`‚ö†Ô∏è GTFS route matching failed for incident ${index}:`, routeError.message);
          // Fallback to text-based route matching
          affectedRoutes = matchRoutes(enhancedLocation, props.description || '');
        }
        
        // Map incident types with better categorization
        const getIncidentInfo = (iconCategory) => {
          const categoryMap = {
            1: { type: 'incident', severity: 'High', desc: 'Accident' },
            2: { type: 'incident', severity: 'Medium', desc: 'Dangerous Conditions' },
            3: { type: 'incident', severity: 'Low', desc: 'Weather Conditions' },
            4: { type: 'incident', severity: 'Medium', desc: 'Road Hazard' },
            5: { type: 'incident', severity: 'Low', desc: 'Vehicle Breakdown' },
            6: { type: 'roadwork', severity: 'Medium', desc: 'Road Closure' },
            7: { type: 'roadwork', severity: 'High', desc: 'Road Works' },
            8: { type: 'incident', severity: 'Low', desc: 'Mass Transit Issue' },
            9: { type: 'incident', severity: 'Medium', desc: 'Traffic Incident' },
            10: { type: 'roadwork', severity: 'High', desc: 'Road Blocked' },
            11: { type: 'roadwork', severity: 'High', desc: 'Road Blocked' },
            14: { type: 'incident', severity: 'Medium', desc: 'Broken Down Vehicle' }
          };
          return categoryMap[iconCategory] || { type: 'incident', severity: 'Medium', desc: 'Traffic Incident' };
        };
        
        const incidentInfo = getIncidentInfo(props.iconCategory);
        
        // Create base alert
        let alert = {
          id: `tomtom_enhanced_${Date.now()}_${index}`,
          type: incidentInfo.type,
          title: `${incidentInfo.desc} - ${enhancedLocation}`,
          description: props.description || incidentInfo.desc,
          location: enhancedLocation,
          coordinates: lat && lng ? [lat, lng] : null,
          severity: incidentInfo.severity,
          status: 'red',
          source: 'tomtom',
          affectsRoutes: affectedRoutes,
          routeMatchMethod: affectedRoutes.length > 0 ? 'GTFS Shapes' : 'Text Pattern',
          iconCategory: props.iconCategory,
          lastUpdated: new Date().toISOString(),
          dataSource: 'TomTom Traffic API v5 + Enhanced Location Processing'
        };

        // ENHANCED: Add start and end times
        alert = enhanceAlertWithTimesAndLocation(alert, props);
        
        alerts.push(alert);
        
        console.log(`‚ú® Enhanced incident: "${props.roadName || 'coordinates'}" ‚Üí "${enhancedLocation}" (${affectedRoutes.length} routes)`);
      }
    }
    
    console.log(`‚úÖ TomTom enhanced: ${alerts.length} alerts with locations and timing`);
    return { success: true, data: alerts, method: 'Enhanced with Location Fallbacks' };
    
  } catch (error) {
    console.error('‚ùå Enhanced TomTom fetch failed:', error.message);
    return { success: false, data: [], error: error.message };
  }
}
// --- END fetchTomTomTrafficWithStreetNames ---
